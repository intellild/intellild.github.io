{"componentChunkName":"component---src-templates-blog-post-js","path":"/react-internals-concurrency-problem/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"mdx":{"id":"ad418f5f-fb48-511f-8f33-a97924523ce7","excerpt":"In the previous post, I introduced the basic structure of React Fiber. Since React introduced concurrent rendering,\nthe reconciliation must be implemented veryâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Internals - Concurrency Problem\",\n  \"date\": \"2021-02-16\",\n  \"description\": \" The concurrency problem is the most complex one of React. Concurrency problems must be treated very carefully, or the app would be full of weird behaviors and bugs that are hard to debug. \"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Link, {\n    to: \"/react-internals\",\n    mdxType: \"Link\"\n  }, \"Back to the stub\"), mdx(\"p\", null), mdx(\"p\", null, \"In the previous post, I introduced the basic structure of React Fiber. Since React introduced concurrent rendering,\\nthe reconciliation must be implemented very carefully.\"), mdx(\"p\", null, \"Assuming we have such a tree:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"jsx\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-jsx\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"<\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token class-name\"\n  }, \"A\")), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \">\")), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token plain-text\"\n  }, \"\\n  \"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"<\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token class-name\"\n  }, \"B\")), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \">\")), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token plain-text\"\n  }, \"\\n    \"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"<\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token class-name\"\n  }, \"C\")), \" \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"/>\")), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token plain-text\"\n  }, \"\\n  \"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"</\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token class-name\"\n  }, \"B\")), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \">\")), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token plain-text\"\n  }, \"\\n\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token tag\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"</\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token class-name\"\n  }, \"A\")), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \">\"))))), mdx(\"p\", null, \"When the user calls \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"setState\"), \" on component B, can we simply push the Fiber of component B onto the task queue?\\nWhen I first looked at the implementation of React, I thought it would be fine. However, I was wrong.\\nThink of the following scenarios:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An update is scheduled on the parent or child tree if we have a work-in-progress work.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An update is scheduled on the parent or child tree after we scheduled an update\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The sub-tree is going to be unmounted by its parent while it is being reconciled\")), mdx(\"p\", null, \"When a task is scheduled for component B, we don\\u2019t know if A or C also scheduled an update. If we simply start the virtual\\nDOM diff work from component B, B could be updated with old props while A would be passing it with new props. It is similar\\nfor other scenarios. This is a concurrency safety problem and would lead to weird behaviors and bugs.\"), mdx(\"p\", null, \"Shall we check the parent tree and the child tree every time we call the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"setState\"), \"? This would be a performance disaster\\nwith duplicated works. React\\u2019s solution is checking the whole tree when the reconciliation starts. This seems to be slow\\nbut actually not at all, since we don\\u2019t need to re-render the components that are not having updates and we can simply\\ncopy the result of the previous render.\"), mdx(\"p\", null, \"The whole picture becomes the following:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Mark the sub-tree has an update\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Schedule a work for root, since we are checking the whole tree\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The reconciler starts to walk down the tree. If the current visited component doesn\\u2019t have any updates, simply copy\\nthe previous result. Having no update means there is no pending \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"setState\"), \" and no new props. Notice that we are not copying\\nthings related to its children, since we don\\u2019t know if there is anything to do with its children.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Check child tree of the component. Then we have two path:\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If all the children don\\u2019t have an update, we have finished the reconciliation of the current component. This is called\\nbailout in React.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a child has updates, follow step 3.\")), mdx(\"ol\", {\n    \"start\": 5\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Once a sub-tree is all checked, \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"completeWork\"), \" is called for the root node of the sub-tree\")), mdx(\"p\", null, \"These processes will be repeated until the whole tree is finished. After the whole tree is finished, React starts the\\ncommit phase introduced in the previous post, including modifying DOM.\"), mdx(\"p\", null, \"This post I introduce the concurrency problem of concurrent rendering and the working process of React reconciler.\\nHowever, it is not enough, since React introduced priorities. In the next post, I am going to talk about how React solves\\nconcurrent rendering with different priorities.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"React Internals - Concurrency Problem","date":"February 16, 2021","description":" The concurrency problem is the most complex one of React. Concurrency problems must be treated very carefully, or the app would be full of weird behaviors and bugs that are hard to debug. "}},"previous":null,"next":null},"pageContext":{"id":"ad418f5f-fb48-511f-8f33-a97924523ce7","previousPostId":"48752f0b-c2a9-57d8-b2cb-c245baf49080","nextPostId":null}},"staticQueryHashes":["2841359383","916993862"]}